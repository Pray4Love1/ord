// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.24;

/// @title MirrorVerifier v0.1
/// @notice Receives Living Inscription proofs emitted from the Rust bridge and
///         persists a minimal record once a recognized Ordinal creator has
///         signed the payload.
contract MirrorVerifier {
    struct MirrorProof {
        bytes32 inscriptionCommitment;
        address creator;
        uint64 blockHeight;
        string mirrorChain;
        bytes signature;
        uint64 timestampMs;
    }

    struct ProofRecord {
        address creator;
        uint64 blockHeight;
        uint64 timestampMs;
        string mirrorChain;
        uint256 storedAt;
        bytes signature;
    }

    /// @dev EIP-712 type hash for the MirrorProof struct.
    bytes32 private constant PROOF_TYPEHASH =
        keccak256(
            "MirrorProof(bytes32 inscriptionCommitment,address creator,uint64 blockHeight,string mirrorChain,uint64 timestampMs)"
        );

    /// @dev EIP-712 type hash for the domain separator.
    bytes32 private constant DOMAIN_TYPEHASH =
        keccak256(
            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
        );

    bytes32 private constant NAME_HASH = keccak256("MirrorVerifier");
    bytes32 private constant VERSION_HASH = keccak256("1");

    address public owner;
    bytes32 public immutable domainSeparator;

    mapping(address => bool) public authorizedCreators;
    mapping(bytes32 => ProofRecord) private records;

    event ProofMirrored(
        bytes32 indexed inscriptionCommitment,
        address indexed creator,
        uint64 blockHeight,
        uint64 timestampMs,
        string mirrorChain
    );

    event CreatorAuthorizationUpdated(address indexed creator, bool allowed);

    error NotOwner();
    error CreatorNotAuthorized();
    error InvalidSignature();
    error ProofAlreadyStored();

    constructor() {
        owner = msg.sender;
        domainSeparator = _computeDomainSeparator();
    }

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    /// @notice Grants or revokes the ability for an Ordinal creator's EVM
    ///         signing key to submit proofs.
    function setCreatorAuthorization(address creator, bool allowed) external onlyOwner {
        authorizedCreators[creator] = allowed;
        emit CreatorAuthorizationUpdated(creator, allowed);
    }

    /// @notice Allows the contract owner to transfer control.
    function transferOwnership(address newOwner) external onlyOwner {
        owner = newOwner;
    }

    /// @notice Submit a proof emitted by the Rust mirror bridge.
    /// @dev The signature must be produced over the EIP-712 digest generated by
    ///      the bridge using the same domain separator and struct layout.
    function submitProof(MirrorProof calldata proof) external {
        if (!authorizedCreators[proof.creator]) {
            revert CreatorNotAuthorized();
        }

        bytes32 structHash = _hashProof(proof);
        bytes32 digest = _toTypedDataHash(structHash);
        address recovered = _recoverSigner(digest, proof.signature);

        if (recovered != proof.creator) {
            revert InvalidSignature();
        }

        bytes32 key = proof.inscriptionCommitment;
        if (records[key].timestampMs != 0) {
            revert ProofAlreadyStored();
        }

        records[key] = ProofRecord({
            creator: proof.creator,
            blockHeight: proof.blockHeight,
            timestampMs: proof.timestampMs,
            mirrorChain: proof.mirrorChain,
            storedAt: block.timestamp,
            signature: proof.signature
        });

        emit ProofMirrored(
            key,
            proof.creator,
            proof.blockHeight,
            proof.timestampMs,
            proof.mirrorChain
        );
    }

    /// @notice Returns a stored mirror record for an inscription commitment.
    function getRecord(bytes32 inscriptionCommitment) external view returns (ProofRecord memory) {
        return records[inscriptionCommitment];
    }

    function _hashProof(MirrorProof calldata proof) private pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PROOF_TYPEHASH,
                    proof.inscriptionCommitment,
                    proof.creator,
                    proof.blockHeight,
                    keccak256(bytes(proof.mirrorChain)),
                    proof.timestampMs
                )
            );
    }

    function _toTypedDataHash(bytes32 structHash) private view returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }

    function _recoverSigner(bytes32 digest, bytes memory signature) private pure returns (address) {
        if (signature.length != 65) {
            revert InvalidSignature();
        }

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        if (v < 27) {
            v += 27;
        }

        if (v != 27 && v != 28) {
            revert InvalidSignature();
        }

        return ecrecover(digest, v, r, s);
    }

    function _computeDomainSeparator() private view returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    DOMAIN_TYPEHASH,
                    NAME_HASH,
                    VERSION_HASH,
                    block.chainid,
                    address(this)
                )
            );
    }
}
